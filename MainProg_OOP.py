'''Доп модуль jeamod с функциями не используем,
т.к. тут все является методами классов и тут же определено'''

import math
#------------------------------Объявление классов и функци-----------------\
round1 = lambda x : round(x, 1)
round2 = lambda x : round(x, 2)
round3 = lambda x : round(x, 3)
z = print

class OperBase:
    '''Проверка переменных будет по предыдущей базе,
    чтобы имена переменных ( тут инстансов) были максимально теми же.
    Операции с готовой базой данных 'base_nonovas':
        
    baseN = OperBase.dump() - открываем и читаем базу в память, 
    
    ВОЗВРАЩАЕМ СТАНДАРТНЫЙ словарь baseN для работы с ним, 
    т.к. у прочитанного шелв-словаря (он внурти ф-ии) другая структура.
    
    OperBase.show(baseN) - выводим 1б базу (base_nonovas) или другой СТАНДАРТНЫЙ словарь)'''
    
    @staticmethod
    def dump():                
        '''Извлекаем первую базу из шелв 'base_nonovas' в наш словарь:
        standart_dict = OperBase.dump()'''
        import shelve
        dump_base = {}
        base = shelve.open('base_nonovas', 'r')
        for _ in base:
            dump_base[_] = base[_]
        base.close()
        return dump_base
    
    @staticmethod
    def show(dump_base):     
        ''' Можем вывести прочитанную  1ю базу на печать'''
        for _ in dump_base:                        
            print( _ , ' >> ', dump_base[_])
        print('------В базе base_nonovas Всего {} строк---'.format(len( dump_base)))
        
    @staticmethod
    def find(name):
        '''Ищем совпадение имени (вводить 'name' в 1м словаре базы.'''
        match_ = False
        for _ in baseN:
            if _ == name:
                match_ = True
                print('!!! --- В 1м словаре найдено совпадение : \n', \
                      name, baseN[name])
        if match_ == False:
            print('Совпадения в 1й базе НЕ найдено.')

                  
class ErrorCreation(Exception):
    '''Класс генерируемого исключения для Pt.__new__ -
    вызывается, если в базе имен экземпляров Pt.base уже есть такое имя'''
    def __init__(self, sms):
        self.sms = sms
    def __repr__(self):
        return self.sms
    # def __str__(self): #спрятать, т.к. в спайдере двойной вывод и type error
    #     print(self.sms)

        
class Pt:
    '''Родительский Класс Точка с 5-ю основными отрибутами "name, x, y, z, info"
    В некоторых наследниках  __инит__ переопределяется, но  методы остаются'''
    
    base = [] # база строковых имен создаваемых экземпляров
    
    def __new__(cls, *args, **kwargs):
        '''Проверяем, есть ли в списке атрибутов объектов создаваемое имя.
        Если есть - возбуждаем исключение, если нет - записываем имя 
        создаваемого объекта в  общую base и передаем экземпляр
        в инит для завершения инициации экземпляра'''
        if args[0] in cls.base:
             raise ErrorCreation \
             ('---- Объект>>  {}  <<существует!! ------'.format(args[0]) )
        cls.base.append(args[0])
        obj = super(Pt, cls).__new__(cls)
        return obj
    
    def __init__(self,name, x, y, z, info = None ):
        '''Основных 5 параметров - имя, координаты, высота, доп.инф-ия'''
        self.n, self.x, self.y, self.z, self.info = name, x, y, z, info
                      
    def __repr__(self):
        '''a - Возвращает все значения аттрибутов экземпляра,
        КРОМЕ .info = 'Примечания, источник' '''
        dictionary = self.__dict__
        string = ''
        for _ in dictionary:
            if _ != 'info':
                string += str( dictionary[_] ) + ' '*3
        return string 

    def __call__(self):
        '''a() - Выводит в поток все значения атрибутов экземпляра,
        ВКЛЮЧАЯ .info(если есть) = 'Примечания, источник' '''
        dictionary = self.__dict__
        string = ''
        for _ in dictionary:
            if dictionary[_] != None :
                string += str( dictionary[_] ) + ' '*3
            else:  
                string += ' '*3
        print( string )
        
    def dist(self, other):
        '''Расстояние между точками-Только для точечных объектов класса Pt'''
        return round( ( (self.x-other.x)**2 + (self.y-other.y)**2 ) ** 0.5, 3 )
        
    def valid(name): # пока без надобности
        '''Эта ф-ия д.б. в том скрипте, где рассчитывается пространство имен
        globals() . т.е. тут - иначе  vars() & locals() будут искать name
        в пространстве имен внутри только Этой ф-ии, если она будкт определена 
        в импортируемом модуле - тогда в этом скрипте не найдет ничего.
        2. Кроме этого - класс переменнной должен быть определен ТОЖЕ 
        в этом же скрипте - тогда эта проверка нормально работает. 
        Добавить сюда третий класс- разрешительных документов.'''
        return isinstance( globals()[name], (Pt)  ) 
    
    @staticmethod
    def createOb( X, block):
        '''Создаем экземпляр класса Х. Указываем нужный нам класс - Х  '''
        globals()[block[0]] = X (*block)
        
    @staticmethod
    def creRes ( *block_):
        createOb( Res, block_)
        
    @staticmethod
    def creVar ( *block_):
        createOb( Var, block_)
        
    @staticmethod
    def weighted_average(q_list): 
        '''Cредневзвешенное значение.
        Структура аргумента - список ниже sample_gravel_list
        вернет одно число float'''
        sum_sample = 0 ; np = 0           
        for _ in q_list :
            sum_sample += _[0]    # сумма процентов
        # print(sum_sample)
        for _ in q_list :
            np += _[0]/sum_sample * _[1] 
        # print(np)
        return np 

    @classmethod
    def validClass(self, arg): # Pt.validClass(angle)
        '''Применял только для угловых величин для применения в тригонометр.
        ф-иях, т.к. не нашел перегрузки для них'''
        return arg.v if isinstance(arg, self) else arg 
    
    @staticmethod
    def proj(alpha, scarp_h) : # Pt.proj(*args)  - projection
        '''Заложение откоса по углу (ГГ.десятичн.градусы) и высоте уступа'''
        alpha_ = Pt.validClass(alpha)
        return scarp_h * 1/(math.tan(math.radians(alpha_)))
    
    @staticmethod
    def prism(ugol1_,ugol2_,h_scarp): # Pt.prism(*args) призма обрушения
        '''Определение призмы обрушения исходя из:
        Угол устойчивого уступа, рабочего уступов, высота уступа
        Переопределена под объекты классов
        prizma(45, 55, 10) - 1й - меньший,устойчивый, второй -  больший, раб.
        prizma(b_sug, a_sug, 10)  , переменные тут  - объекты Pt
        prizma( 45, 55, w1.vsk(pgs) ), последний аргумент - переменная(число)
        Улы можно вводить в любом порядке, вернет положительное по модулю
        величина угла д.б. целые.десятичные
        '''
        ugol1, ugol2 = [ Pt.validClass(x) for x in (ugol1_, ugol2_) ]
        return abs(round((Pt.proj(ugol1,h_scarp) - Pt.proj(ugol2,h_scarp)),2))
    
    @staticmethod
    def sqScarp(ang_ust, h_lay): # (b_sug, x.vsk)
        '''Площадь Треугольн. сечения уступа по Углу устойчивости и Мощности'''
        return Pt.proj(ang_ust, h_lay) * h_lay * 0.5 
    
    @staticmethod
    def sqPillar(ang_ust, h_lay_up, h_lay_down): # (b_sug, x.vsk, x.pgs)
        '''Площадь Прямоуг. сечения под откосом по Углу устойчивости и Мощности'''
        return Pt.proj(ang_ust, h_lay_up) * h_lay_down
    
    @staticmethod
    def goList(lst): # исходник - просто список элементов
        '''Возвращает список пар (первый, следующий элемент) списка
        если это список объектов -вернет их как через ф-ию call()'''
        out_lst = []
        for i in range(0, len(lst)):
            if i + 1  < len(lst):
                ind = i
            else:
                ind = -1
            out_lst.append(( lst[ind], lst[ind+1] ))
        return out_lst 

class Well(Pt):
    '''Класс Скважин (wells: w1, w2, ..) и Шурфов(pits: p1,p2, ..).
    Дополнительно к родит.классу  вводим 4 атрибута, всего будет 8 :
    name, x, y, z, z_prs - НАША глубина  ПРС,
                    z_sug -              суглинка,
                    z_pgs -              песчано - гравийной смеси,
                    prs0 - слой прс снимаемый общим внутрихозом (default=0.0)
    Имена атрибутов реальные.
    Атрибуты: мощность вскыши - w.vsk
              мощность пeсч-грав смеси - w.pgs
                       ПРС             - w.prs''' 
    def __init__(self, name, x, y, z, prs1, sug2, pgs3, prs0 = 0.2):
        self.n, self.x, self.y, self.z, self.z_prs, self.z_sug, self.z_pgs = \
        name, x, y, z, prs1, sug2, pgs3
        self.prs = prs1 if prs0 == 0 else prs0 # принятая мощность ПРС
        self.vsk = round(sug2 - prs1,2) if prs0 == 0 else round(sug2 - prs0,2)
        '''Определение мощности всего слоя вскрыши (прс+суглинок) на скважине,
        исходя из того, какую мощность слоя ПРС мы примем для снятия 
        согласно общего проекта внутрихоза 0,2 или по нашему отчету(0,5):
        Логика:   если  prs_0 = 0.0, то используем наш prs_1 = 0.5
                  если  prs_0 = 0.2, то используем его.
        10 - prs_1 if prs_0 == 0 else 10 - prs_0'''
        self.pgs = round(pgs3 - sug2, 2)
        '''Определение всей мощности песч-гравийн смеси на скважине.'''
        self.sq_vsk = Pt.sqScarp(b_sug, self.vsk) # S сечения вскрыши в борту
        # S сечения целика ПГС под бортом суглинка:
        self.sq_pgs_pillar = Pt.sqPillar(b_sug, self.vsk, self.pgs - h_pod)
        # S сечения борта ПГС в своем откосе:
        self.sq_pgs_scarp = Pt.sqScarp(ueo, self.pgs - h_pod)
        # S всего сечения ПГС (борт+целик(не доходя 10 см да самого низа))
        self.sq_pgs = round3( self.sq_pgs_pillar + self.sq_pgs_scarp )
        self.proj_vsk = self.proj(b_sug, self.vsk)
        self.proj_pgs = self.proj(ueo, self.pgs - h_pod)
        
class Board(Pt):
    '''Класс борт, уступ. '''
    def __init__(self, name_, x1, x2):
        self.n = name_
        self.obj1 = x1 # begin well object - w1
        self.obj2 = x2 # end well - p2
        #расстояние между скважинами борта по верху вскрыши:
        self.len = x1.dist(x2) 
        # длина борта ПГС но низу откоса Вскрыши:
        self.len_pgs = self.len - x1.dp - x2.dp
        # объем оставляемой вскрыши в бортах откоса:
        self.vol_vsk = Board.volAveVal \
        ( self.len, x1.sq_vsk, x2.sq_vsk ) - x1.con_vsk - x2.con_vsk
        
        # объем оставляемого целика ПГС под бортами вскрыши:
        self.vol_pgs_pillar = Board.volAveVal \
        (self.len, x1.sq_pgs_pillar, x2.sq_pgs_pillar) - \
        x1.con_pgs_pillar - x2.con_pgs_pillar 
        
        # объем оставляемого ПГС в своих откосах: (можно пренебречь уголками)
        self.vol_pgs_scarp = Board.volAveVal \
        (self.len_pgs, x1.sq_pgs_scarp, x2.sq_pgs_scarp)
        # объем всей потери ПГС в одном борту(откос+целик)
        self.vol_pgs = self.vol_pgs_pillar + self.vol_pgs_scarp

    @staticmethod   
    def volAveVal(len_, sec_square_1, sec_square_2 ): # average value
        '''Среднее значение объема в борту по его длине и двум сечениям'''
        return round1(len_ * ( sec_square_1 + sec_square_2 ) / 2 )        
               

class Var(Pt):
    '''Родительский для Res, т.к. тут перегружены операторы для instance.v
    Класс ИСХОДНЫХ переменных - имя, описание, значение, информация
                        .n       .d        .v    .info (None по умолчанию'''
    def __init__(self, name, description, value, inform = None):
        self.n, self.v, self.d, self.info = \
            name, value, description, inform
        print( 'Исходное знач. - ', self.__repr__() )

#---------------------   Перегрузка операторов в классе Var  -----------
#---------------- Работают только в классах переменных Var & Res -------
#----------Чтобы в формуле можно было так: a + b, а не  a.v + b.v-------

#    -----------------------------------Сложение       
    def __add__(self, alien):   #  экземпляр СЛЕВА
        return self.v + alien
    def __radd__(self, alien):   #  экземпляр СПРАВА
        return self.v + alien
#    -----------------------------------Вычитание
    def __sub__(self, alien):   #  экземпляр СЛЕВА
        return self.v - alien
    def __rsub__(self, alien):   #  экземпляр СПРАВА
        return alien - self.v
#    -----------------------------------Умножение       
    def __mul__(self, alien):   #  экземпляр СЛЕВА
        return self.v * alien
    def __rmul__(self, alien):   #  экземпляр СПРАВА
        return self.v * alien
#    -----------------------------------Деление     
    def __truediv__(self, alien):   #  экземпляр СЛЕВА
        return self.v / alien
    def __rtruediv__(self, alien):   #  экземпляр СПРАВА
        return alien / self.v
#    -----------------------------------Степень  
    def __pow__(self, alien):   #  экземпляр СЛЕВА
        return self.v ** alien
    def __rpow__(self, alien):   #  экземпляр СПРАВА
        return alien ** self.v               

class Res(Var):
    '''Класс РАСЧИТАННЫХ данных - имя, описание, значение, информация
    .n          .d               .v        .info (None по умолчанию
    При инициации выводит на печать все атрибуты методом self.__repr__
    Является наследником Var, т.к. там перегружены операторы для self.v'''
    def __init__(self, name, description, value, inform = None):
        self.n, self.v, self.d, self.info = name, value, description, inform
        print( 'Рассчитанное знач. -', self.__repr__() )
        
#--------------------------------------------------------------------
#----------------------- Define myFoos :
creRes = Pt.creRes # (вставляем только строковый набор s)
creVar = Pt.creVar # (вставляем только строковый набор s)
createOb = Pt.createOb # (Var, s) создаем новый объект        
qq = Pt.base  # qq вывод списка имен всех экземпляров всех классов из Pt.base 
q = OperBase.find # qq('name') поиск в базе Навли сущестующего имени переменной 
proj = Pt.proj  # proj(alpha, scarp_h) Заложение откоса (угол, высота) уступа
prism = Pt.prism # prism(ugol1_,ugol2_,h_scarp) призма обрушения 1й< , 2q> 
validClass = Pt.validClass # validClass(angle) для тригонометрич.ф-ий
sqScarp = Pt.sqScarp # (ang_ust, h_lay): # (b_sug, x.vsk) S сечения уступа
sqPillar = Pt.sqPillar # (ang_ust, h_lay_up, h_lay_down): # (b_sug, x.vsk, x.pgs)
goList = Pt.goList # (any_list) исходник - просто список элементов(не объектов)

#-----------------------ТЕЛО ПРОГРАММЫ-------------------                           

baseN = OperBase.dump()  # открыли полную 1ю базу baseN
#OperBase.show(baseN)    # вывести полную базу BaseN

#--------------------3. Технические решения

z('''
#========================================================
#                     3. Технические решения
#            3.1 Проектн. мощн и режим работы карьера
#========================================================

Система разработки месторождения – сплошная, продольная, однобортовая.

\nПринимаем:\n''')


# кол-во раб дней с 2010 по 2020
rb = [249,248,249,247,247,247,247,247,247,247,248]
srb = round(sum(rb)/len(rb))
createOb(Var, ('srb', 'Среднегодовое количество рабочих дней 2010-20120', srb))
#-------------------Производительность карьера расчет, запасы
[ Pt.createOb(Var, s) for s in [
( 'gpk', 'Годовая производительность карьера по лицензии, куб.м./год' , 150000 ),
('gpk_p', 'Принятая по техзаданию и проекту годовая производительность карьера', 144000,\
 'Для ровного счета взяли 12т/мес'),
( 'bzB' , 'Разведанные Балансовые Блок В, куб.м.', 280307),
( 'bzC1', 'Разведанные Балансовые Блок С1, куб.м.', 91784),
( 'go' , 'Площадь горного отвода, кв.м. ' , 100000 ),
( 'zo' , 'Площадь земельного отвода,  кв.м. ', 100000+106070+10000,'Еще в балке zob' ),
( 'zob', 'Земельный отвод под растительностью в балке' , 84962 ),
( 'Kp' , 'Коэффициент крепости по Протодьяконову', 0.8 ),
('krd' , 'Количество рабочих дней в году принимаем :', srb.v+4),
( 'ps' , 'Продолжительность смены,ч' , 8 ),
( 'rn' , 'Продолжительность рабочей недели, дн', 5) ,
('lic','Лицензия на право пользования недрами ','БРН №80836 ТР от 15.06.2017г')  
]]
#--------------------------Углы откосов
print('\nПринимаем:\n')

[ Pt.createOb(Var,s) for s in [ 
( 'uro', 'Угол откоса РАБОЧЕГО уступа ПГС, градусы', 45),
( 'ueo', 'Угол откоса Нерабочего уступа ПГС, градусы', 35),
('a_sug','Угол откоса РАБОЧЕГО уступа СУГЛИНКА, градусы', 55),
('b_sug','Угол откоса УСТОЙЧИВОГО уступа СУГЛИНКА, градусы', 45),
('a_prs','Угол откоса РАБОЧЕГО уступа ПОЧВЕННОГО слоя, градусы', 45),
('b_prs','Угол откоса Нерабочего уступа ПОЧВЕННОГО слоя, градусы', 35),
('h_kro','Потери - Снимаемый слой ПГС в кровле, м', 0.1),
('h_pod','Потери - Оставляемый слой ПГС в подошве, м', 0.1),
( 'bz' , 'Разведаннные Балансовые запасы(B+C), куб. м.', bzB + bzC1 ),
('Vsk_all','Объем всей вкрыши ГО, включая ПРС',1049116,'Из Подсчета запасов')]]


[ Pt.createOb( Well, s ) for s in [  # создаем объекты скважин Well
        
#  n         x           y          z     prs1  sug2  pgs3
 
( 'w1',  436770.863, 1284184.445, 191.98, 0.3, 10.0, 14.9 ),
( 'w2',  436752.059, 1284431.132, 191.33, 0.5, 12.0, 13.6 ),
( 'w3',  436599.916, 1284263.940, 191.42, 0.3,  9.7, 15.5 ),
( 'w4',  436592.147, 1284365.858, 191.76, 0.3, 10.7, 15.2 ),
( 'w5',  436584.378, 1284467.776, 190.19, 0.3, 10.5, 14.7 ),
( 'w6',  436428.969, 1284343.435, 188.78, 0.5, 10.0, 15.5 ),
( 'w7',  436416.698, 1284504.420, 190.20, 0.3, 11.0, 12.7 ),
( 'w8',  436422.834, 1284423.928, 190.48, 0.4, 11.1, 15.0 ),
( 'w9',  436325.501, 1284524.349, 188.41, 0.4, 10.8, 12.4 ),
( 'w10', 436184.953, 1284474.108, 184.92, 0.4, 10.0, 11.1 ),
( 'p1',  436761.461, 1284307.789, 192.76, 0.5, 10.0, 15.5 ),
( 'p2',  436183.793, 1284390.725, 185.84, 0.3,  9.2, 12.2 )

]  ]

# создаем список ОБЪЕКТОВ границ горного отвода
marks = ( w1, p1, w2, w5, w7, w9, w10, p2, w6, w3 )
# создадим список Объектов всех скважин
wells = ( w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, p1, p2)
# names of boards:
b_names = [ 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'b10' ]

# -------------Насыпная плотность, в целике, коэффиц. разрыхления

print('Принимаем объемные плотности в целике, насыпные плотности\
      и коэффициенты разрыхления ПРС, суглинка и ПГС:\n')

                                 # for sand
 #мощность (м) опроб.\ насыпн. плотность в сухом состоян.\ влажность пробы
sample_sand_list = [ 
        (4.9, 1550, 3.0),
        (1.6, 1568, 3.1),
        (5.8, 1585, 3.3),
        (4.9, 1570, 3.2),
        (4.2, 1565, 3.0),
        (5.5, 1555, 3.0),
        (1.7, 1585, 3.1),
        (1.1, 1580, 2.9),
        (5.5, 1595, 3.1),
        (3.0, 1615, 3.3) ]
    
                                # for gravel
      
sample_gravel_list = [ # процент фракций \ насыпная плотность
        (11.25, 1410),
        (11.10, 1390),
        ( 6.79, 1302),
        ( 5.84, 1298),
        ( 4.15, 1298) ]       

                             # count for gravel & sand 
                             
#  времен. перемен. для насыпной плотности песка, гравия
npp_v = sum(x[1] for x in sample_sand_list) / len(sample_sand_list) # песка
npg_v = Pt.weighted_average(sample_gravel_list) # гравия
per_gr = sum( x[0] for x in sample_gravel_list ) # общее процентн. содерж. гр.
# средняя влажность из всех проб песка:
vl_p = sum( x[2] for x in sample_sand_list ) / len (sample_sand_list) 

[ Pt.createOb(Res, s) for s in [
    ('npp', 'Насыпная плотность песка (средняя=средневзвеш.), кг/м.куб)',
      round(npp_v), 'рассчитано из прот№9 Испытан.ПГС,стр.7'),
    ('npg', 'Насыпная плотность гравия (средневзвеш.), кг/м.куб)',
      round(npg_v), 'рассчитано из прот№9 Испытан.ПГС,стр.9')      ]]
       
[ Pt.createOb(Var, s) for s in [
         ('op_ch', 'Объемная плотность ПРС (чернозема) в целике, т/куб.м.',\
          1.3, 'Из проекта общей рекультивации, с.39'),
         ('op_sug', 'Объемная плотность суглинка в целике, т/куб.м.', \
          1.9, 'Из консультации со специалистом В.В.'),
         ('Kp_pgs', 'Коэффициент разрыхления ПГС',\
          1.2,'прошлые изыскания(1.1-1.2)'),
         ('np_pgs','Насыпная плотность ПГС, т/куб.м.',\
          1.7,'прошлые изыскания(1.6-1.7)'),
         ('Kp_ch','Коэффициент разрыхления ПРС (чернозема)',\
          1.22,'по таблицам'),
         ('Kp_sug','Коэффициент разрыхления суглинка',\
          1.22,'по таблицам')     ]]
         
# по таблицам Кр прс: 1,2-1,3; наш суглинок: 1,14-1,28; ПГС: 1,14-1,28       
         
[ Pt.createOb(Res, s) for s in [
        ('np_ch','Насыпная плотность ПРС(чернозема)',round(op_ch / Kp_ch, 2)),
        ('np_sug','Насыпная плотность суглинка', round(op_sug / Kp_sug, 2)),
        ('op_pgs','Объемная плотность ПГС в целике', round(Kp_pgs*np_pgs, 2))
        ]]
#----------------------Потери
print('\n17.1.2 Расчет потерь и разубоживания\n') # --------------------------

# используется пока только для подсчета потерь, после КПТ уточнить !!! :
# internal angles  decimal - x.av - внутренние углы участка десятичные:
w1.av = 60.701178472222222222222222222222
p1.av = 180
w2.av = 106.68626901
w5.av = 180
w7.av = 180
w9.av = 148.00238005555555555555555555556
w10.av= 110.46688708333333333333333333333
p2.av = 100.12068055555555555555555555556
w6.av = 194.02260483333333333333333333333
w3.av = 180

# создадим доп. атрибуты для списка Объектов w.. границы (раньше нельзя)
# x.dp - delta pgs - поправка в длину линии пгс на уровне низа откоса вскрыши
# x.con_vsk - Corner vsk - объемы Сугл.Вскрыши в Уголочках на углах участка
for x in marks:
    x.dp = x.proj_vsk*math.tan(math.radians(90 - x.av/2))
    x.con_vsk = 1/3*x.sq_vsk*x.dp # формула объема пирамиды,основ.-попер.сеч
    x.con_pgs_pillar = x.proj_vsk * x.dp * 0.5
    
# создаем список объектов бортов между скважинами по границе
for (num, name) in enumerate(b_names):
    if num + 1 < len(b_names):
        idn = num + 1
    else:
        idn = 0
    Pt.createOb(Board, [ name, marks[num], marks[idn] ] )
   
#                   основные борта по сторонам света
bN = [b1, b2]              
bE = [b3, b4, b5, b6]
bS = [b7]
bW = [b8, b9, b10]
#                    потери ПИ в откосах по основным бортам:
pN = round1(sum(x.vol_pgs for x in bN) )
pE = round1(sum(x.vol_pgs for x in bE) )
pS = round1(sum(x.vol_pgs for x in bS) )
pW = round1(sum(x.vol_pgs for x in bW) )
# сумма потерь по основным бортам:
p_b = round(sum(x for x in [pN, pE, pS, pW]))   
z('Потери ПИ по основным бортам с севера до запада:\n ', pN, pE, pS, pW)

[Pt.createOb(Res, s) for s in [
('Pb','Потери ПИ во всех бортах', p_b),
('Vkro', 'Потери - объем зачищаемого слоя ПИ кровли', round(go * h_kro)),
('Vpod', 'Потери - объем оставляемого ПИ в подошве', round(go * h_pod)) ]]             

#                   оставляемая вскрыша в бортах, объем:
vN = sum(x.vol_vsk for x in bN)
vE = sum(x.vol_vsk for x in bE)
vS = sum(x.vol_vsk for x in bS)
vW = sum(x.vol_vsk for x in bW)
# сумма оставляемой вскрыши по основным бортам:
vsk_b = round(sum(x for x in [vN, vE, vS, vW]))
    

Pt.createOb(Res,('Ppgs','Общие потери ПГС(кровля,подошва,борты)', Pb+Vkro+Vpod))
Pt.createOb(Res,('Vvsk_b', 'Объем вскрыши, отсавляемый в бортах', vsk_b))
Pt.createOb(Res,('Viz', 'Извлекаемые (промышленные) запасы ПИ', bz-Ppgs ))
Pt.createOb(Res,('Ppp', 'Плановый процент потерь', round(Ppgs/bz, 4) ))
Pt.createOb(Res,('Kiz', 'Коэффициент извлечения ПИ', round(Viz/bz, 4) ))

z('Для табл.30,31 - в табл.8.3 стр 58 геологии отсальные мощности\
  не забыть учесть транспортные потери 0,4%\n\nДалее: для п.3.3.3-------------\
  Экскаватор - характеристики, элементы производительность.---------------\n')

lst = [
('kvs', 'Объем ковша экскаватора, куб.м.', 1.9, 'с.21 харак-тики ZX450-3'),
('pos', 'Призма обрушения суглинка при средн.толщ. уступа 5,35',\
 Pt.prism(b_sug, a_sug, 10.36/2) ),
('popB', 'Призма обрушения ПГС для 5,8 по блоку В',\
 Pt.prism(ueo, uro, 4.17 ),'(макс 5.8 на 3й скважине) для средняя по С 4,17'),
('popC', 'Призма обрушения ПГС для 5,5 по блоку C',\
 Pt.prism(ueo, uro, 2.8 ), '(макс 5.5 на 6й скважине) для средняя по С 2,8')
        ]
[Pt.createOb(Res, s) for s in lst]

createOb(Res, ('Hvsk','Средняя мощность вскрыши', \
               (10.56 + 10.38) /2 - w1.prs ))

[createOb(Var, s) for s in [
('Hb', 'Средняя мошность ПГС по блоку В', 4.17, 'Из подсчета запасов' ),
('Hc', 'Средняя мощность ПГС по блоку С1', 2.8, 'Из подсчета запасов' )]]
creRes('Kh', 'Коэффициент отношения мощностей блоков В/С1', Hb/Hc)
#-----------------расчет уступов экскаватора
z('''\n-----------расчет уступов экскаватора---------------
  
макс глубина черпания экскаватоар 7,63 (из схемы с22 их буклета)
средняя мощность вскрыши по блоку В = 10,56 - 0,2 = 10,36
                                  С = 10,48 - 0,2 = 10,28
                   максимальная по обоим блокам - 11,8   
Средняя по всему участку  {hvsk}                               
выходит, чтол надо не одним уступом, а двумя.

До Расчета ширины рабочих площадок указывать максимально возможные глубины.
А в след. пунктте уже рассчитанные средние(или максимальные?)

Средняя мощность уступа 10,36/2= 5,18
Максим 11,8/2 = 5,9
Для 5,18 призма обрушения сост ..{pos_}..
максимальная высота полууступа 5,9 для него призма - 1,77
ее и показывать перед таблицами6,7.
При данных рабочих , устойчивых углах откоса максимаьная глубина разработки
суглинка может достигать 6,10 при условии величении призмы обрушения до 1,83.
Исходя из схемы для вскрыши максимальная высота черпания д.б. 8,04м

Для ПГC средняя мощность по блоку В 4,17  по блоку С - 2,8
                          максимальная 5.8 из обоих блоков
Для ПГС призма обрушения составляет:
для средняя 4.17 по В - ..{popB_}..,  
для средняя 2,8 по С1)  - ..{popC_}..
для максиамльн 5,8 - 2.48. Предусмотреть в местах максимальности
отработку 2 подуступами

При данных углах ПГС исходя из схемы максимальная глубина разработки
может быть 4.95 при условии увеличения призмы обрушения до 2.12
Эту величину и рассчитывать перед таблицами 6 ,7
Исходя из схемы для ПГС максимальная высота черпания д.б. 5,17
Схему из буклета в автокаде доделать.\n'''\
.format(hvsk = Hvsk, pos_ = pos.v, popB_ = popB.v, popC_ = popC.v))
    
z('''для 3.3.3 Расчет ширины рабочих площадок---------------------------------------
  
Максимальные значения копания для таблиц 6,7 взять из предыдущего пункта - 
отдельно для Вскрыши, ПГС\n''')

z('\nШ.р.п. экскаватора на вскрыше суглинка:')

[Pt.createOb(Var, s) for s in [
('Hvig', ' Максимальная высота (паспорт) выгрузки экскаватора', 7.65),
('Rk', 'Максимальный радиус (паспорт) черпания экскаватора', 12.06),
('Rka', 'Макс.(паспорт) радиус черпания на уровне стояния', 11.84),
('Grh_frak','Фракции нашего грохота - 3х дечный,нам надо 5-20,20-40,40+',None)
 ]]

z('''\nRчу = {} \n A = 1.5 * {} =  {}\
  Пп = {}, По = {} , Пб = {}, будет 2 призмы обруш - на максимальные значения
  
  Принмаем A на суглинках вскрыши  = {}
  '''.format(Rka.v,Rka.v,1.5*Rka.v, 4.0, 1.5,'разная', math.ceil(1.5*11.84)))

A_ = math.ceil(1.5*11.84)

z('''Для сугл - призма обруш для максим уступа 5,9 - 1,77 при максимально 
  разрешенной глубине черпания экс на сеглинках 6,1.
  
  Расчет Пб вскрышн на суглинках :
      перечисляем угол устойчивого , угол рабочего суглинка
      Максимальная высота уступа 5,9 м - призма для него 1.77
      
  Расчет Пб на добычном пгс:
      перечисляем  устойчивый и рабочий ,
      максимальняа высоат уступа (разрешенная из схемы глубины экск.)
      4,95 - Пб = 2,12))
    
Исходя из этого:
    ширина раб площ экскававатора:
        На сугл:
            Шр вскрышного = ''')
    
createOb(Res, ('A', 'Ширина заходки экскаватора на Вскр(сугл),м', A_))

[createOb(Var, s) for s in [
('Hv','Максимальная высота вскрышного уступа Сугл,м',5.9,'из схемы экскав.'),
('Hd', 'Максимальная высота добычного уступа ПГС,м', 4.95,'из схемы экскав.'),
('Pp', 'Ширина проезжей части самосвала ', 4),
('Po','Ширина обочины на уступе  с нагорной стороны', 1.5),
('Rmax', 'Максимальный радиус выгрузки экскаватора(+-2,51)', 10.3,\
         'из схемы доп глубина Экскаватора.dwg'),
 
]]

z('\nРасчет призм обрушенияо уступов-------------------------------')

createOb(Res, ('Povu','Призма обрушения Сугл вскрышного уступа,м',\
         prism(b_sug, a_sug, Hv)))
createOb(Res, ('Podu','Призма обрушения ПГС добычного уступа,м', \
         prism(ueo,uro,Hd)))

z('\nРасчет ширины рабочих площадок экскаватора-----------------------------')

createOb(Res, ('Shv','Ширина рабочей площадки экскаватора \
при отработке вскрышного Суглинки уступа, A+Pp+Po+Povu', (A+Pp+Po+Povu)))

#-----------------если Грохот Внизу---------------------------------
#z('''\nНа ПГС добычной уступ будет со смещением к краю борта, чтобы дотянуться 
#  до выгрузки в бункер грохота, поэтому расчет чуть другой\n''')
#-------------------------------------------------------------------------

createOb(Res,('pgs_proj','Заложение Макс рабочего откоса ПГС',proj(uro, Hd)))
createOb(Res,('sug_proj','Заложение Макс рабочего откоса Суг',proj(a_sug,Hv)))

[createOb(Var, s) for s in [
        ('Ej','Ширина ходовой части экскаватора',3.5,'с.22 буклета'),
        ('kamgr', 'Грузоподъемность а/с, кг', 19000) ]]

#-----------------если Грохот Внизу----------------------------------
#z('''\nЗаходка экск на пгс: Podu + Ej/2 + Rka 
#  макс залож откоса раб пгс + призма безопас пгс + половина ширины ходовой
#  части экс + радиус черпания экскаватора на уровне земли\n''')
#Apgs_ = math.floor(Podu + Ej/2 + Rka)
#------------------------------------------------------------
Apgs_ = A_
createOb(Res, ('Apgs','Ширина заходки экскаватора на ПГС', Apgs_ ))

z('Рсчитанная заходка на пгс = {}, принимаем {}'.format(Apgs.v, Apgs.v))

createOb(Res, ('Shd','Ширина рабочей площадки экскаватора \
при отработке добычного ПГС уступа, Apgs+Pp+Po+Podu', (Apgs+Pp+Po+Podu)))

z('\nЭто было для таблиц 6 и 7 Ещее грузоподъемность самосв {}'.format(kamgr))

z('\nАвтомобильный транспорт-----для табл12---------------------------------')
z('табл не меняется, взять ee из старого отчета\n')
[createOb(Var, s) for s in [
('kam','Марка автосамосвала', 'KAMAZ-6522-43'),
('kamf','Колесная формула а/с','6x6'),
('kamw', 'Мощность двигателя а/с, кВт', 294),
('kamm', 'Масса полная а/с, кг', 33100),
('kamvk', 'Геометрическая вместимость Объем кузова \
 (платформы) а/с, куб.м.', 12),
('kamr', 'Радиус разворота а/с, м', 12.5),
('kamv', 'Скорость движения, км/час', 80)
]]
kamgr()

z('\nОпределение ширины проезжей части-----------------------\
  будем принимать двух полосное, чтобы не пересчитывать отдельную дорогу \
  для грохота (он 3 м шириной, а а/с = 2,5)')
z('''
  соответсвует старой схеме
  Шп.ч=2*(a+y) + x

Где, а=2,5 м – ширина кузова автомобиля (примерно равна ширине машины по скатам с);
у-ширина предохранительной полосы между наружным колесом машины и кромкой проезжей части.
У=0,5+0,005V
    где V= 5 км/час – скорость движения автомобиля по внутрикарьерным дорогам.
    У= 0.5+0.005*5=0.525 м принимаем 0.6 м
x=2y - безопасный зазор между встречными автосамосвалами
    x=2*0.6 = 1.2

Шп.ч.= 2*(2.5+0.6)+1.2=7.4.''')

#----------------------------предыдущий расчет автодороги------------------
'''Явный расчет (с переменными) ширины автодороги приведен здесь,
но его нужно подгнать под мой, который выше:

Схема к определению ширины проезжей части автодороги')
z('\nДалее считаем ширину проезжей части автодороги-------------------------')

#y = 0.5*x = 0.5+0.005*V   # - так в проекте. Сначала считаем 2е, потом 1е.

ac = idb('ac', 'Ширина кузова а/с по скатам', 2.5, db) 
V = idb('V', 'Скорость движения а/с по внутрикарьерным дорогам', 5, db)

yp = 0.5+0.005*V
yp = ((math.ceil( ( yp )*10))/10) # округляем вверх до десятых
yp = idb('yp', 'Рассчитанная Ширина предохранительной полосы между \
наружным колесом машины и кромкой проезжей части', yp, nb)

xb = yp/0.5
xb = idb( 'xb', 'Рассчитанный Безопасный зазор \            
между встречными автосамосвалами', xb, nb)

Spc1 = ac+ 2*yp
Spc1 = math.ceil( Spc1 ) # округляем вверх до десятых
Spc1 = idb('Spc1', 'Рассчитанная Ширина проезжей части автодороги', Spc1, nb)
'''
#------------------------------------------------------------------------

z('\n---------------------------Расчет ширины рабочих площадок погрузчика---')

[createOb(Var, s ) for s in [
('Rp', 'Радиус поворота погрузчика ,м', 5.62),
('Srp','Ширина заходки погрузчика(равна экскаваторной  по суглинку) ', A.v),
('Soa','Ширина обочины автодороги, м', 1.5),
('Sk','Ширина кювета, м', 1.5),
('Hrp','Наибольшая высота разгрузки погрузчика(К,стр17pdf)', 2.81),
('Hcp','Максимальная высота черпания погрузчика(взято из отчета)', 3.5) ]]

Shp_ = Srp + Pp + Soa + Sk
createOb(Res, ('Shp','Рассчитаная Ширина рабочей площадки погрузчика',Shp_))

#-------------------------------------------------------------------------

z('\nБульдозер на вскрышных и вспомогательных работах-------------------')       

[createOb(Var, s) for s in[
('lphb', 'Длина поперечного хода бульдозера', 30),
( 'Sop', 'Ширина отвала ПРС', 10) ]]

createOb(Res, ('Shb', 'Рассчитанная Ширина рабочей площадки бульдозера', \
               (lphb+Sop)))

#-------------------------------------------------------------------------


z('\n3.5. Оборудование, машины и механизмы \
\nдля вскрышных и добычных работ--------------------------------------------')
z('Есть расчеты экскаватора на суглинке и на ПГС :\n')
z('-------------------------------Рассчет производительности экскаватора :-\
                                    на вскрыше (суглинок)\n')

[createOb(Var, s) for s in [ 
('tpz','Время на выполнение подготовительно-заключительных операций,мин',35),
('tln','Время на личные надобности(уточнить,сколько), мин', 10 ),
('y', 'Объемный вес в целике Вскрыши(суглинок), т/куб.м', op_sug.v ),
('yy', 'Объемный вес в разрыхленном (суглинок), т/куб.м', np_sug.v ),
('Kr','Коэффициент разрыхления (суглинок)', Kp_sug.v ),
('ce', 'Продолжительность цикла экскаватора при погрузке, сек', 25 ),
('tup', 'Время установки автосамосвала под загрузку, мин', 0.3 )
]]

createOb(Res, ('tsm', 'Продолжительность смены, мин', 60*ps.v ))

Qk_ = kvs*1/Kr 
createOb(Res, ('Qk', 'Объем горной массы в целике в одном ковше, куб.м',\
               round2(Qk_)))

nk_ = kamgr*0.001/(Qk*y)
[createOb(Res, s) for s in [
('nk', 'Число ковшей, погружаемых в самосвал, шт', math.ceil( nk_ ) ),
('nc', 'Число циклов экскаваций в минуту, шт', 60/ce )
]]

tps_ = nk/nc 
createOb(Res, ( 'tps', 'Время погрузки одного самосвала, мин', \
               round1(tps_)))

Hb_ = (tsm-tpz-tln)*Qk*nk/(tps+tup) 
createOb(Res,('Hbe_sug','Производительность экскаватора Hb (суглинки) в смену',\
               round(Hb_,0) ))

#--------------------------расчет производительности экскаватора ------------
z('-------------------------------Рассчет производительности экскаватора :-\
                                    на Добыче ПГС')
z(tpz, tln, ce, tup, ps, kvs, sep = '\n')
[createOb(Var, s) for s in [ 
('y_p', 'Объемный вес в целике ПГС, т/куб.м', op_pgs.v ),
('yy_p', 'Объемный вес в разрыхленном виде ПГС, т/куб.м', np_pgs.v ),
('Kr_p','Коэффициент разрыхления ПГС', Kp_pgs.v ),
]]

createOb(Res, ('tsm_p', 'Продолжительность смены, мин', 60*ps.v ))

Qk_ = kvs*1/Kr_p
createOb(Res, ('Qk_p', 'Объем горной массы ПГС в целике в одном ковше, куб.м',\
               round2(Qk_)))

nk_ = kamgr*0.001/(Qk_p*y_p)
[createOb(Res, s) for s in [
('nk_p', 'Число ковшей, погружаемых в самосвал, шт', math.ceil( nk_ ) ),
('nc_p', 'Число циклов экскаваций в минуту, шт', 60/ce )
]]

tps_ = nk_p/nc_p 
createOb(Res, ( 'tps_p', 'Время погрузки одного самосвала, мин', \
               round1(tps_)))

Hb_ = (tsm_p - tpz - tln)*Qk_p*nk_p/(tps_p + tup) 
createOb(Res,('Hbe_pgs','Производительность экскаватора Hb (ПГС) в смену',\
               round(Hb_,0) ))

#-------------------------  производительность Погрузчика -----------------
z('''\n------------------------Рассчет производительности погрузчика ZW220                                        
при производстве горных работ выполнен в соответствии НТП.------------''')

z('\nДанные для таблицы ? 13 - теххарактеристики погрузчика:\n')

z(Hrp, Rp, sep = '\n')

[createOb(Var, s) for s in [
('pog','Марка погрузчика','ZW220' ),
('poggr','Грузоподъемность погрузчика, кг',6120 ),
('pogV', 'Вместимость ковша погр(ISO до краев)., куб.м.', 2.6 ),
('pogrk', 'Ширина режущей кромки ковша погр., мм', 2910 ),
('pogw', 'Мощность двигателя погр., кВт', 164 ),
('poguc', 'Наибольшее усилие черпания погр., кН', 169 ),
('pogv', 'Наибольшая скорость движения погр.,км/час', 34.5 ),
('pogm', 'Масса погрузчика, кг', 17250 ),
('pogK', 'Коэффициент наполнения ковша погр.',1.0 ),
('pogKb', 'Коэффициент использования погр. во времени', 0.8 ),
('pogKc', 'Коэффициент использования погр.по организационным условиям', \
 0.8) ]]

z('\nТеперь данные для рассчета:\nРабота погр. при разр.и погрузке на авт-рт')
z('Выше в перечислении.Расчет делаем только на ПГС(для погрузки готового)')

z('\nДля рассчета продолжит. цикла tc :')

[createOb(Var, s) for s in [
('tn', 'Время наполнения ковша погр.породой, с' , 4  ),
('tgr', 'Время движения погрузчика к месту разгрузки,с', 5 ),
('tr', 'Время разгрузки погрузчика, с', 2 ),
('tp', 'Время возвращения погрузчика в забой,с', 5 ),
('ts', 'Время переключения передач погрузчика,с', 12) ]]

z('\nПроверяем расчет Тцикла tc')
tc_ = tn + tgr + tr + tp + ts
createOb(Res, ('tc', 'Продолжительность цикла погрузчика,с', tc_ ))
z('Тцикла = {} + {} + {} + {} + {} = {}'.format(tn.v,tgr.v,tr.v,tp.v,ts.v,tc.v))

z('\nСчитаем Производительность погрузчика в смену Hbp:')                                     
Hbp_ = (ps*3600)/tc*pogV*pogK/Kr_p*pogKb*pogKc
createOb(Res, ('Hbp', 'Прозводительность (норма выработки) \
погрузчика в смену, куб.м/смена', round(Hbp_,0)))

z('Проверка формулы:\nHbp = ({}*3600)/{} * {} * {}/{} * {} * {} = {}'\
  .format(ps.v, tc.v, pogV.v, pogK.v, Kr_p.v, pogKb.v, pogKc.v, Hbp.v))

#-------------------------Расчет производительности бульдозера ----------

z('\n------------------------------Расчет производительности бульдозера ----')
z('\nБульдозер на вскрышных и вспомогательных работах-----------------------')
z('\nДанные для таблицы 14: ')

[createOb(Var, s) for s in [ 
( 'bul', 'Марка бульдозера', 'D180LT'),
( 'bulw', 'Мощность бульдозера, кВт', 145),
( 'bultk', 'Тяговые класс/ усилие бульдозера, класс/кН', '13/290'),
( 'bullo', 'Ширина отвала бульдозера, мм', 3460),
( 'bulho', 'Высота отвала бульдозера, мм', 1450),
( 'bulup', 'Подъем отвала бульдозера, мм', 1100),
( 'buldn', 'Опускание отвала бульдозера , мм', 480),
( 'bulm', 'Масса бульдозера, кг', 20530),
( 'bulk', 'Колея бульдозера, мм', 1900),
( 'bulv', 'Максимальная скорость движения бульдозера, м/с', 4) ]]

z('''\nСменная производительность бульдозера на планировочных \        
работах внутри карьера, кв. м.-------------------------------------------''')

createOb(Var, ('bulkn','Коэффициент использования бульдозера по времени',0.9 ))
bultp_ = ( lphb + Sop ) * bulv 
createOb(Res, ( 'bultp', 'Время одного прохода бульдозера, с', round( bultp_, 1)))
bultr_ =  ( lphb  ) * bulv 
createOb(Res, ('bultr', 'Время обратного хода бульдозера, с', round(bultr_, 1)))
createOb(Var, ( 'bulnpr', 'Число проходов по одному месту', 4 ))

Pbpl_ = ( 3600 * ps * bullo/1000  * lphb * bulkn ) / ( ( bultp + bultr ) *bulnpr)
createOb(Res, ( 'Pbpl', 'Сменная прозводительность бульдозера \
на планировочных работах, кв.м.', math.ceil( Pbpl_)))

#----------------------------------------------------------------------------
#!!!            производительность бульдозера , куб. м. на ПРС
#----------------------------------------------------------------------------
z('\nСменная производительность бульдозера  при разработке \
и перемещении грунта (ПРС), куб.м.----------------------------------------')
ps()
z('\nСчитаем V  - объем грунта в разрыхленном состоянии, \
перемещаемый отвалом бульдозера, м3--------------------------------------')
z(bullo, bulho, b_prs )  # ширина, высота отвала, угол внутр трения ПРС
z('\nсначала Считаем a (sppg)- ширина призмы перемещаемого грунта-----')
sppg_ = bulho*0.001/math.tan(math.radians(b_prs.v))
createOb(Res, ('sppg', 'Ширина призмы перемещаемого грунта ПРС, м',\
               round(sppg_,2)))

z('\nСчитаем  в цифрах V  - объем грунта в разрыхленном состоянии, \
перемещаемый отвалом бульдозера, м3  со значениями:')

Vr_ = bullo*0.001*bulho*0.001*sppg*0.5  
createOb(Res, ('Vr', 'Объем грунта в разрыхленном состоянии, \
перемещаемый отвалом бульдозера, м3', round(Vr_,1)))
z( ' Vr = ( {} * {} * {} ) / 2 = {}'.format( bullo.v, bulho.v, sppg.v, Vr.v))

[createOb(Var, s) for s in [
('Ky', 'Коэффициент, учитывающий уклон местности \
на участве работ (приложение V НТП).', 1.0),
('Ko', 'Коэффициент, учитывающий увеличение производительности \
при работе бульдозера с открылками. Для этого типа бульдозера Ко = 1,0.',1.0)
]]

z('\nСчитаем Коэффициент, учитывающий потери при её транспортировке:')

lphb()
createOb(Var, ('B', 'для вскрыши ПРС – коэффициент потерь на 1 м пути \
транспортировки;',0.006))

z('\nКоэффициент, учитывающий потери при её транспортировке:')
Kpg_ = 1 - lphb * B ; 
createOb(Res, ('Kpg', 'Коэффициент, учитывающий потери \
при её транспортировке', round(Kpg_,2)))
B(); Kpg()

z('\nдля Кп цифры в формуле те же')

Krg_ = Kp_ch.v
Ki_ = bulkn.v
[createOb(Var, s) for s in [
('Ki', 'коэффициент использования бульдозера во времени', Ki_),
('Krg', 'Коэффициент разрыхления грунта ПРС (табл.IV.1 НТП ', Krg_)]]

z('\nДля Продолжительность одного цикла (в секундах):')

[createOb(Var, s) for s in [
('lpr', 'Длина пути резания бульдозера,м', 5), 
('v1', 'скорость движения бульдозера при резании, м/с', 0.9) ]]
z(Ki, Krg, lpr, v1, lphb)

[createOb(Var, s) for s in [
('v2', 'Скорость движения бульдозера с грунтом, м/с', 1.2),
('v3', 'Скорость холостого ( обратного) хода, м/с', 1.6),
('tnb', 'Время переключения скоростей, сек', 9),
('tpb', 'Время разворота бульдозера, сек', 10),
('to', 'Время опускания отвала, сек', 2.5)  ]]

z('\nСчитаем Тц Продолжительность одного цикла (в секундах):')

Tc_ = lpr/v1 + lphb/v2 + (lpr+lphb)/v3 + tnb +2*tpb + to 
createOb(Res, ('Tc', 'Продолжительность одного цикла бульдозера, сек',\
               round(Tc_)))
z('Тц = {}/{} + {}/{} + ({} + {})/{} + {} + 2*{} + {} = {}'\
.format(lpr.v,v1.v,lphb.v,v2.v,lpr.v,lphb.v,v3.v,tnb.v,tpb.v,to.v,Tc.v ))

z('\nСчитаем Пс Сменная производительность бульдозера:')

Ps_ = (3600 * ps * Vr * Ky * Ko * Kpg * Ki) / ( Krg * Tc ) 
createOb(Res, ('Ps','Сменная производительность бульдозера на вскрыше, м3/смена',\
               round(Ps_,1)))
z('Пс = ( 3600 * {} * {} * {} * {} * {} * {} ) / ( {} * {} ) = {}'\
  .format( ps.v, Vr.v, Ky.v, Ko.v, Kpg.v, Ki.v, Krg.v, Tc.v, Ps.v )  )
z('''
#----------------------------------------------------------------------------
#!!!    Расчет сколько времени на вскрышу, ее площади и объемы, календарный
#----------------------------------------------------------------------------
''')
z('-'*60)
createOb(Res, ('V_prs_go', 'Объем ПРС на Горном Отводе ', go * w1.prs ))
createOb(Res, ('Vsk', 'Вскрыша к выемке', Vsk_all - V_prs_go - Vvsk_b ))
createOb(Res, ('days_vsk', 'Количество смен для выемки всей вскрыши одним экск.',\
               math.ceil(Vsk / Hbe_sug)))
z('''\nПодсчет всей вскрыши:
    Оставшаяся вскрыша для выемки =
    вся вскрыша включая ПРС {} - снимаемый прс на 10 га по 0,2 м {} -
    вскрыша оставляемая в бортах  {} = {}
    При производительности экскаватора {}  в смену
    вся вскрыша выбирается за  {} смен одним экскаватором
    Надо ставить 2 экскаватора на вскрышу на 2,5 года
    '''.format(Vsk_all.v, V_prs_go.v, Vvsk_b.v, Vsk.v, Hbe_sug.v, days_vsk.v ))

createOb(Res, ('otn', 'Условная мощность изымаемой вскрыши к 1 кв.м. площади ГО, куб.м.', \
               Vsk / go, 'Этоя вся вскрышп минус потери в бортах'))
z(''' \nОтношение объема изымаемой вскрыщи к 1 кв.м. площади ГО:
    вскр. к выемке  / площадь ГО = 
    {} \ {} = {}'''\
    .format(Vsk.v, go.v, otn.v))

createOb(Res, ('M_sug1','Месячная производительность 1 экскаватора на вскрыше,куб.м.',\
         21 * Hbe_sug ) ) 
z('\nМесячная производительность экскаватора на вскрыше :\
  21 * дневную производительность {} = {}  кубов в месяц '\
  .format( Hbe_sug.v , M_sug1.v ))
createOb(Res, ('M_s1','Месячная площадь выемки вскрыши(кв.м.) 1м экск. д.б.:',\
         M_sug1 / otn))
createOb(Res, ('K_ms1', 'Количество месяцев под выемку вскрыши одним экскав.:',\
              math.ceil(go / M_s1 )))
createOb(Res, ('K_ms', 'Количество месяцев под выемку вскрыши двумя экскават', \
               math.ceil( K_ms1 / 2 )))
creRes('M_s','Месячная площадь выемки вскрыши(кв.м.) 2мя экск. ',\
       go/K_ms)
creRes('Vm','Месячный объем вскрыши 2мя экскаваторами, кубов :', round(M_s*otn,-2),\
       'Считался из удельного отношения объема Вск к площади ГО')
z('\nВыемка вскрыши первого месяца куб м  будет {} \
  остальных {} по {} в месяц . Всего {}'\
  .format(Vsk - (K_ms-1)*Vm, K_ms-1, Vm.v, Vsk.v))
vnach = Vsk-(K_ms-1)*Vm + Vm.v*5
z('Обратная засыпка вскрыши : начинаем  на 7м месяце - т.е. 6 месяцев вскрыши надо\
  где-то расположить: {} + (6-1)*{} = {}'.format(Vsk-(K_ms-1)*Vm, Vm.v, vnach))
z('\nПлощадь выемки вскрыши 2мя экск первого месяца будет {}'\
  .format((Vsk - (K_ms-1)*Vm)/otn))
z('\nВыемка вскрыши начало - июнь 2018, всего {} \
  конец -...... '.format(K_ms.v))

z('''
#----------------------------------------------------------------------------
#!!! Расчет сколько времени , объемы , площади на добычу ПГС
#----------------------------------------------------------------------------)
''')
[createOb(Var,s) for s in [
('Sb','Площадь ПГС верхняя по блоку В', 57568 ),
('Sc','Площадь ПГС верхняя по блоку С1', 27296) ]]
creVar('Spn','Вся площадь Пгс по низу по В и С', 77418.2  )
creRes('Km', 'Количество месяцев на добычу ПГС при месячном плане 12т ', 
       round(Viz/12000,5 ))
creRes('Spgs','Площадь ПГС верхняя по рудному телу по низу вскрыши', Sb+Sc  )
Kh(); Hb(); Hc()

creRes('Sc_usl','Условная площадь С1 при мощности 4.17', round3(Sc/Kh ))
creRes('Susl','Вся условная площадь ПГС, при одинаковой мощности 4.17',\
       round3(Sb+Sc/Kh))
creRes('Smb','Площадь 1 мес. Пгс по блоку В', \
       round(Susl / Km + 0.37286  ))
creRes('Smc','Площадь 1 мес. Пгс по блоку С1', round((Susl/Km)*Kh ))

z('''Площадь блока С1 д.б. при мощности, как в блоке В - 
    Sc_usl {} = Sc {} / Kh {} , 
т.е. вся площадь была бы (при одинаковой мощности 4,17 как в  В)
    Susl {}= Sb {} + Sc {} /Kh {}. 
Тогда площадь 1 месяца по бл.В :
    Smb {} = Susl {} /Km {},
соответственно         по бл.С1 : 
    Smc {} = Susl {} /Km {} * Kh {}'''\
.format( Sc_usl.v,Sc,Kh.v, \
        Susl.v,Sb.v,Sc.v,Kh.v, \
        Smb.v,Susl.v,Km.v, \
        Smc.v,Susl.v,Km.v,Kh.v ))
creRes('otb','Условная мощность изымаемого Пгс поля блок В', \
       12000/Smb - 0.000614721855453304,\
       'Используется только для меня дря расчета месяцев добычи' )
creRes('otc','Условная мощность изымаемого Пгс к поля блок С', \
       12000/Smc + 0.000191137261155383,\
       'Используется только для меня дря расчета месяцев добычи' )

z('''\nSb*otb+Sc*otc = Viz. \
  otc*Smc
Out[26]: 12000.0

otb*Smb
Out[27]: 12000.0 Проверка сошлась.\n''')

z('''Определяем объем месячной добычи: \n
  месячная добыча будет 12000/мес. Первый месяц выработки 280279-276000 =4279\n
  далее до конца добычи по 12 тыс куб  / месяц
  Проверка: 12000 * 23 + 4279 = 280279 - Это равно извлекаемым запасам Viz ''')


#------------------Отвальное хозяйство------------
z('''
#----------------------------------------------------------
#                 Отвальное хозяйство
#----------------------------------------------------------''')

creVar('Uotv', 'Угол отвала Вскрышных при бульдозероной механизации',\
       30, 'СБОРНИК вспомогательных материалов для разработки пособия \
       по рекультивации земель, нарушаемых в процессе разработки \
       карьеров и строительства автомобильных дорог, Москва, 2000\
       таблица 3.33. Углы устойчивых откосов и допустимые высоты отвалов')
creVar('Hotv', 'Максимальная высота уступа отвала Вскр', 15, Uotv.info)
z('\nНужная Средняя площадь отвалов (полусумма верха и низа) ',round(vnach/Hotv,1))

[createOb(Var,s) for s in [
('sn1','Площадь низа 1го отвала Вскрыши', 20000 ),
('sv1','Площадь верха 1го отвала Вскрыши', 7040 ),
('sn2','Площадь низа 2го отвала Вскрыши', 16026 ),
('sv2','Площадь верха 2го отвала Вскрыши', 4512 )
]]
creRes('Vo1','Объем 1го отвала суглинка', (sn1+sv1)/2*Hotv )
creRes('Vo2','Объем 2го отвала суглинка', (sn2+sv2)/2*Hotv )
creRes('Votv','Объем Двух отвалов суглинка', Vo1 + Vo2 )

z('''\n
  Надо куда-то девать первые 6 месяцев вскрыши.
  объем этой вскрыши будет за 6 месяцев {}'''\
  .format(vnach))

z('\nНачиная с седьмого месяца, суглинок вскрыши сразу перевозится в выработанное \
пространство, а эти 2 отвала будут засыпаны обратно \
в конце добычи, начиная с 21 месяца. Засыпаться будут бульдозером(сталкиваться)\
(погрузку в автосамосвалы не надо)' )

z('снимаем ПРС с площади ', zo ,'мощностью ', w1.prs, ' получится: ',\
 (zo)*w1.prs, 'кубов')
[createOb(Var,s) for s in [
('sn3','Площадь низа 3го отвала ПРС', 10000  ),
('sv3','Площадь верха 3го отвала ПРС', 5858  ),
('H3', 'Высота отвала ПРС', 5.5 ),
('V3', 'Снимаемый объем ПРС с участков кроме балки', (zo)*w1.prs ) ]]

creRes('Vo3', 'Проектный Объем 3го отвала ПРС', (sn3+sv3)/2*H3 )

z('''\nДалее - отвал ПРС Проектные Параметры : 
    угол борта 30, высота {0} площадь под него
      нижней площади  {1},
      верхней площади  {2}  равен {3} кубов,  а нам 
      нужно разместить сейчас кроме с балки {4}, 
      разница проект минус факт {5} . Принимаем это.'''.format(\
      H3.v, sn3.v, sv3.v, Vo3.v, V3.v, Vo3-V3))
    
#---------------------------Грохот
z(''')
---------------------------------------------------------------
                            Грохот
---------------------------------------------------------------''')
Grh_frak()  
spg = '''\nСПЕЦИФИКАЦИЯ Грохот Maximus 522T
Внести в проект, можно отдельным пунктом, твм где производительности
и техн. характеритсики остальных механизмов ,описание грохота  с сайта ,
добавить таблицу технических характеристик грохота , взяв их из бууклета,
произвордительность не рассчитывать отдельно, взять ее оттуда.
Длина
При транспортировке 18.850 мм
В рабочем положении 19.950 мм
Ширина
При транспортировке 3.000 мм
В рабочем положении 17.900 мм
Высота
При транспортировке 3.520 мм
В рабочем положении 6.800 мм
РАЗМЕРЫ ГРОХОТА:
Верхняя дека 6.700 x 1.525 мм
Средняя дека 6.700 x 1.525 мм
Нижняя дека 6.100 x 1.525 мм
ЕМКОСТИ:
Объем загрузочного бункера 9,3 м³
Объем топливного бака 320 л
Объем гидравлического бака 500 л
Вес 37 200 кг
Двигатель CAT, 129 HP (96kW)
Производительность до 650 т/чac'''
z(spg)
z('''\nСрок службы карьера составляет 6.5 лет, 
  из них вскрышные работы проводятся в течении 16 месяцев 
  в период с июня 2018г по сентябрь 2019г., 
  добычные работы при годовом объеме добычи 144 тыс. м3 производятся 
  в течение 26 месяцев в период с августа 2018г по июль 2020г., 
  технический этап рекультивации производится в течении 21 месяца 
  в период с августа 2020г по апрель 2022г, 
  биологический этап рекультивации проводится в течении 30 месяцев 
  в период с мая 2022г по октябрь 2024г в теплый период года – 
  с мая по октябрь включительно  ''')
z('Глубина изучения карьера составила 12,2-17,0 м. \n')

#--------------Транспортировка горной массы . Наша таблица 28

z('''
#--------------------------------------------------------------------------
#--------------Транспортировка горной массы . Наша таблица 28
#--------------------------------------------------------------------------
\nДля 5. Карьерный автотранспорт. Таблица 28 - Транспортировка горной массы''')

z('Есть расчет в эксель, он почти идентичен.')

input('press enter..')
